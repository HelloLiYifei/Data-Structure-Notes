# 1. 绪论

## 1.1 数据结构研究内容

早期，计算机主要用于数值计算。
随着计算机应用领域的扩展，计算机被越来越多地用于非数值计算

**数据结构**是一门研究**非数值计算**的程序设计中计算机的**操作对象**以及他们之间的**关系**和**操作**的学科

## 1.2 基本概念以及术语

### 1.2.1 数据、数据元素、数据项和数据对象

#### 数据(Data)

- 是能输入计算机且能被计算机处理的**各种符号的集合**
  - 信息的载体
  - 是对客观事物符号化的表示
  - 能够被计算机识别、存储和加工
- 包括
  - 数值型的数据：整数、实数等
  - 非数值型的数据：文字、图像、图形、声音等

#### 数据元素(Date element)

- 是数据的**基本单位**，在计算机程序中通常作为一个整体进行考虑和处理
- 也简称为元素，或称为记录、结点或顶点
- 一个**数据元素**可由若干个**数据项**组成 (Data Item)

#### 数据项

- 构成数据元素的不可分割的最小单位

- **数据、数据元素、数据项三者之间的关系:**

  数据 > 数据元素 > 数据项

  -- 图片 --

#### 数据对象(Data Object)

- 是**性质相同的数据元素的集**，是数据的一个子集

#### 数据元素与数据对象

- 数据元素——自称数据的基本单位

  ​	与数据的关系：是集合的个体

- 数据对象——性质相同的数据元素的集合

  ​	与数据的关系：是集合的子集

### 1.2.2 数据结构()

- 数据结构
  - 数据元素不是孤立存在的，它们之间存在着某种关系，**数据元素相互之间的关系称为结构(Structure)**
  - 是指**相互之间存在一种或多种特定关系**的数据元素集合
  - 或者说，数据结构是**带结构的**数据元素的集合
- 数据结构包括以下三个方面的内容：
  1. 数据元素之间的逻辑关系，也称为**逻辑结构**。
  2. 数据元素及其关系在计算机内存中的表示（又称为映像），称为数据的**物理结构**或数据的**存储结构**
  3. 数据的**运算和实现**，即对数据元素可以试驾的操作以及这些操作在相应的存储结构上的实现

#### 数据结构的两个层次

- 逻辑结构
  - 描述数据元素之间的逻辑关系
  - 与数据的存储无关，独立于计算机
  - 是从具体问题抽象出来的数字模型
- 物理结构（存储结构）
  - 数据元素及其关系在计算机存储器中的结构（存储方式）
  - 是数据结构在计算机中的表示
- 逻辑结构与存储结构的关系
  - 存储结构是逻辑关系的映像与元素本身的映像
  - 逻辑结构是数据结构的抽象，存储结构是数据结构的实现
  - 两者综合起来建立了数据元素之间的结构关系

##### 逻辑结构的种类

1. 划分方法一

   - 线性结构

     有且仅有一个开始和一个终端结点，并且所有结点都最多只有一个直接前驱和一个直接后继
     例如：线性表、栈、队列、串


   - 非线性结构

     一个结点可能有多个直接前驱和直接后继
     例如：树、图

2. 划分方法二——四类基本逻辑结构

   1. 集合结构：结构中的数据元素除了**同属于一个集合**的关系外，无任何其它关系
   2. 线性结构：结构中的数据元素之间存在着**一对一**的线性关系
   3. 树形结构：结构中的数据元素之间存在着**一对多**的层次关系
   4. 图形结构或网状结构：结构中的数据元素之间存在着**多对多**的任意关系

##### 存储结构的种类

1. 顺序存储结构

   - 用一组**连续**的存储单元**依次**存储数据元素，数据元素之间的逻辑关系由元素的**存储位置来表示
   - C语言中用数组来实现数序存储结构

2. 链式存储结构

   - 用一组**任意**的存储单元存储数据元素，数据元素之间的逻辑关系用**指针**来表示

   - C语言中用指针来实现链式存储结构

     例：head->a->b->c->end

3. 索引储存结构

   - 在存储结点信息的同时，还建立附加的**索引表**
   - 索引表中的每一项称为一个**索引项**
   - 索引项的**一般形式**是：**（关键字，地址）**
   - 关键字是能**唯一标识**一个结点的那些数据项
   - 若每个节点在索引表中都有一个索引项，则该索引表称之为**稠密索引(Dense Index)**。若一组结点在索引表中只对应一个索引项，则该索引表称之为**稀疏索引(Sparse Index)**

4. 散列存储结构

   - 根据节点的关键字直接计算出该结点的存储地址

### 1.2.3 数据类型和抽象数据类型

- 在使用高级程序设计语言编写程序时，必须对程序中出现的每个变量、常量或表达式，明确说明它们所属的**数据类型**
  - 例如，C语言中
    - 提供`int`，`char`，`float`，`double`等基本数据类型
    - 数组、结构、共用体、枚举等构造数据类型
    - 还有指针、空(`void`)类型
    - 用户也可以`typedef`自己定义数据类型
- 一些最基本数据结构可以用数据类型来实现，如数组、字符串等
- 而另一些常用的数据结构，如栈、队列、树、图等，不能直接用数据类型来表示
- 高级语言中的数据类型明显的或隐含的规定了在程序执行期间变量和表达的所有可能的取值范围，以及在这些数值范围上所允许进行的操作
- 数据类型的作用
  - 约束变量或常量的**取值范围**
  - 约束变量或常量的**操作**

#### 数据类型(Data Type)

- 定义：**数据类型**是一组性质相同的**值的集合**以及定义于这个值集合上的**一组操作**的总称

数据类型 = 值的集合 + 值集合上的一组操作

#### 抽象数据类型(**A**bstract **D**ata **T**ype, ADT)

是指一个数学模型以及定义在此数学模型上的一组操作

- 由用户定义，从问题抽象出**数学模型**（逻辑结构）
- 还包括定义在数据模型上的一组**抽象运算**（相关操作）
- 不考虑计算机内的具体存储结构与运算的具体实现算法

##### 抽象数据类型的形式定义

抽象数据类型可用（D, S, P）**三元组**表示
其中: D是数据对象；
	 S是D上的关系集；
	 P是对D的基本操作集。

一个抽象数据类型的**定义格式**如下：

ADT 抽象数据类型名 {
	数据对象:<数据对象的定义>
	数据关系:<数据关系的定义>
	基本操作:<基本操作的定义>
} ADT 抽象数据类型名

其中:

- 数据对象、数据关系的定义用伪代码描述
- 基本操作的定义格式为：
  - 基本操作名 (参数表)
    初始条件:    <初始条件描述>
    操作结果:    <操作结果描述>
  - **基本操作**定义格式说明
    - 参数表：赋值参数只为操作提供输入值
                    引用参数以`&`打头，除可提供输入值外，还将返回操作结果
    - 初始条件：描述操作执行之前数据结构和参数应满足的条件，若不满足，则操作失败，并返回相应出错信息。若初始条件为空，则省略之
    - 操作结果：说明操作正常完成后，数据结构的变化状况和应返回的结果

抽象数据类型(ADT)定义举例：Circle的定义

ADT 抽象数据类型名 {
	Data
		数据对象的定义
		数据元素之间逻辑关系的定义
	Operation
		操作1
			初始条件
			操作结果描述
		操作2
			......
		操作n
			......
} ADT 抽象数据类型名

ADT Circle {
	数据对象: D={r,x,y | r,x,y 均为实数}
	数据关系: R={<r,x,y>|r是半径，<x,y>是圆心坐标}
	基本操作:
	Circle(&C,r,x,y)
		操作结果:构造一个圆
	double Area(C)
		初始条件:圆已经存在
		操作结果:计算面积
	double Circumference(C)
		初始条件:圆已经存在
		操作结果:计算周长
	......
} ADT Circle

抽象数据类型(ADT)定义举例: 复数的定义

ADT Complex{
	D = {r1, r2|r1,r2 都是实数}
	S = {<r1,r2>|r1是实部，r2是虚部}
	assign (&C, v1, v2)
		初始条件：空的复数C已存在
		操作结果：构造复数C, r1, r2分别被赋以参数v1, v2的值
	destroy (&C)
		初始条件：复数C已存在
		操作结果：复数C被销毁
	getReal (Z, &realPart)
		初始条件：复数已存在
		操作结果：用realPart返回复数Z的实部值
	getImag (Z, &ImagPart)
		初始条件：复数已存在
		操作结果：用ImagPart返回复数Z的虚部值
	Add (z1, z2, &sum)
		初始条件：z1, z2是复数
		操作结果：sum返回两个复数z1, z2的和
	......
} ADT Complex

## 1.3 抽象数据类型的表示与实现

### 1.3.1 抽象数据类型的实现

抽象数据类型可以通过固有的数据类型(如整型、实型、字符型等)来表示和实现。即利用处理器中已存在的数据类型来说明新的结构，用已经实现的操作来组合新的操作。

## 1.4 算法和算法分析

### 1.4.1 算法和算法分析一

- 算法的定义

  - 对特定问题**求解方法和步骤**的一种描述，它是**指令**的有限**序列**。其中每个指令表示一个或多个操作

    简而言之，算法就是**解决问题的方法和步骤**

- 算法的描述

  - 自然语言：英文、中文
  - 流程图：传统流程图、NS流程图
  - 伪代码：类语言：类C语言
  - 程序代码：C语言程序、JAVA程序......

- 算法与程序

  - **算法**是解决问题的一种方法或一个过程，考虑如何将输入转换成输出，一个问题可以有多种算法
  - **程序**是用某种程序设计语言对算法的具体实现

- 算法特性：一个算法必须具备以下五个重要特性

  - **有穷性** 一个算法必须总是在执行有穷步之后结束，且每一步都在又穷时间内完成
  - **确定性** 算法中的每一条指令必须有确切的含义，没有二义性，在任何条件下，只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出
  - **可行性** 算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现
  - **输入** 一个算法有零个或多个输入
  - **输出** 一个算法有一个或多个输出

- 算法设计的要求

  - **正确性(Correctness)**

    算法满足问题要求，能正确解决问题
    算法转化为程序后要注意:

    1. 程序中**不含语法错误**
    2. 程序对于**几组输入数据**能够得出满足要求的结果
    3. 程序对于**精心选择的、典型、苛刻且带有刁难性**的几组输入数据能够得出满足要求的结果
    4. 程序对于**一切合法的输入数据**都能得出满足要求的结果

    通常以**第三层**意义上的正确性作为衡量一个算法是否合格的标准

  - **可读性(Readability)**

    1. 算法主要是为了人的阅读和交流，其次才是为计算机执行，因此算法应该易于人的理解
    2. 另一方面，晦涩难懂的算法易于隐藏较多错误而难以调试

  - **健壮性(Robustness)**

    1. 指当**输入非法数据**时，算法恰当的做出反应或进行相应处理，而不是产生莫名其妙的输出结果
    2. 处理出错的方法，不应是中断程序的执行，而应是返回一个表示错误或错误性质的值，以便在更高抽象层次上进行处理

  - **高效性(Efficiency)**

    要求花费尽量少的时间和尽量低的存储需求

### 1.4.2 算法和算法分析二

算法分析的目的是看算法实际是否可行，并在同一问题存在多的算法时可进行性能上的比较，以便从中挑选出比较优的算法。

一个好的算法首先要具备正确性，然后是健壮性，可读性，在几个方面都满足的情况下，主要考虑**算法的效率**，通过算法的效率高低来评判不同算法的优劣程度

算法效率两个方面来考虑

- **1. 时间效率**：指的是算法所耗费的**时间**
- **2. 空间效率**：指的是算法执行过程中所耗费的**存储空间**
- 时间效率和空间效率有时候是矛盾的

**算法的时间效率的度量**

- 算法时间效率可以用依据该算法编制的程序在计算机上执行**所耗费的时间**来度量
- 两种度量方法
  - 事后统计
    - 将算法实现，测算其时间和空间开销
    - **缺点**：编写程序实现算法将花费较多的时间和精力：所得实验结果依赖于计算机的软硬件环境因素，掩盖算法本身的优劣
  - 事前分析
    - 对算法所消耗资源的一种估算方法
- 事前分析方法
  - 一个算法的运行时间是指一个算法在计算机上运行所耗费的时间，大致可以等于计算机执行一种简单的操作（如赋值、比较、移动等）所需的**时间**与算法中进行的简单操作**次数乘积**
    **算法运行时间 = 一个简单操作所需的时间(语句频度) × 简单操作次数** 
  - 为了便于比较不同算法的时间效率，我们仅比较它们的数量级

**算法时间复杂度的渐进表示法**

- 若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)，f(n)的极限值为**不等于零的常数**，则称f(n)是T(n)的同数量级函数。记作T(n) = O(f(n))，则称O(f(n))为**算法的渐进时间复杂度** *(O是数量级的符号)*，简称**时间复杂度**

  ![image-20250121230032068](.\img\image-20250121230032068.png)

**算法时间复杂度定义**

算法中**基本语句重复执行的次数**是**问题规模n**的某个函数f(n)，算法的时间度量记作：**T(n) = O(f(n))**

- **基本语句重复执行的次数**

  - 算法中重复执行次数和算法执行时间成正比的语句

  - 对算法运行时间的贡献最大

  - 执行次数最多

- **问题规模n**
  - n越大算法的执行时间越长
  - 排序：n为记录数
  - 矩阵：n为矩阵的阶数
  - 多项式：n为多项式的项数
  - 集合：n为元素个数
  - 树：n为树的结点个数
  - 图：n为图的顶点数或边数

它表示随着n的增大，算法执行的时间的增长率和f(n)的增长率相同，称渐进时间复杂度

### 1.4.3  算法和算法分析三

#### 分析算法时间复杂度的基本方法

定理1.1

![image-20250122142354491](.\img\image-20250122142354491.png)

忽略所有**低次幂象和最高次幂系数**，体现出增长率的含义

1. 找出**语句频度最大**的那条语句作为**基本语句**
2. 计算**基本语句**的频度得到问题规模n的某个函数f(n)
3. 取其数量级用符号"O"表示

#### 算法时间复杂度分析

**时间复杂度是由嵌套最深层语句的频度决定的**

~~~ c++
void exam (float x[][], int m, int n) {
    float sum[];
    for (int i = 0; i < m ; i ++) {
        sum[i] = 0.0;
        for (int j = 0; j < n; j ++) {
            sum[i] += x[i][j];
        }
    }
    for (i = 0; i < m; i ++)
        cout << i << ":" << sum[i] << endl;
}
~~~

$$
\begin{align}
f(n) = m * n
\end{align}
$$

$$
T(n) = O(m * n)
$$

例1 N×N矩阵相乘

~~~ c++
for (i = 1; i <= n; i ++)
    for (j = 1; j <= n; j ++) {
        c[i][j] = 0;
        for (k = 1; k <= n; k++) {
            c[i][j] = c[i][j] + a[i][k] * b[k][j];
        }
    }
~~~

$$
T(n) = O(n^3)
$$

~~~ c++
i = 1;
while (i <= n)
    i = i * 2;
~~~

$$
T(n) = O(log_2n)
$$

### 1.4.4  算法和算法分析四

#### 算法时间复杂度

有的情况下，算法基本操作重复执行的次数还随问题的**输入数据集**不同而不同

- **最坏时间复杂度**：指在最坏情况下，算法的时间复杂度
- **平均时间复杂度**：指在所有可能输入实例在等概率出现的情况下，算法的期望运行时间。
- **最好时间复杂度**：指在最好情况下，算法的时间复杂度

- 一半总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长

- **对于复杂的算法，可以把它分成几个容易估算的部分，然后利用大O加法法则和乘法法则，计算算法的时间复杂度**

  - 加法规则
    $$
    T(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O(max(f(n),g(n)))
    $$

  - 乘法规则
    $$
    T(n) = T1(n) * T2(n) = O(f(n)) * O(g(n)) = O(f(n) * g(n))
    $$

#### 算法时间效率的比较

- **当n取得很大时，指数时间算法和多项式时间算法在所需时间上非常悬殊**

  ![image-20250124113641130](.\img\image-20250124113641130.png)

#### 渐进空间复杂度

- 空间复杂度：算法所需存储空间的度量，
  记作：**S(n) = O(f(n))**

  其中**n**为问题的规模（或大小）

- 算法要占据的空间

  - 算法本身要占据的空间，输入/输出，指令，常数，变量等
  - 算法要使用的**辅助空间**

#### 设计好算法的过程

抽象数据类型 = 数据的逻辑结构 + 抽象运算（运算的功能描述）
