# 树和二叉树

**树形结构**（非线性结构）

- 结点之间有分支
- 具有层次关系

### 5.1.1 树的定义

**树**(Tree)是$n(n\geq0)$个结点的**有限集**
	若n=0，称为**空树**；
	若n>0，则它满足如下两个条件：
		1.**有且仅有一个**特定称为**根**(Root)的结点
		2.**其余结点**可分为$m(m\geq0)$个互不相交的**有限集** T1, T2, T3, ..., Tm，其中每一个集合本身又是一棵树，并称为根的**子树**(SubTree)
		<img src=".\img\image-20250319223040505.png" alt="image-20250319223040505" style="zoom:67%;" />

### 5.1.2 树的基本术语

**结点**：数据元素以及指向子树的分支
**根节点**：非空树中无前驱结点的结点
结点的**度**：结点拥有的子树数
**树的度**：树内各节点的度的最大值
度$\neq$0 **分支结点** **非终端结点**根结点以外的分支结点称为**内部节点**
度= 0 **叶子** **终端结点**
结点的子树的根称为该节点的**孩子**，该结点称为孩子的**双亲**
拥有共同的双亲的结点称为**兄弟**
双亲在同一层的结点称为**堂兄弟**
结点的**祖先**：从根到该结点所经分支上的所有结点
结点的**子孙**：以某结点为根的子树的任一节点
树的**深度**：树中结点的最大层次
**有序树**：树中各节点
<img src=".\img\image-20250319233941889.png" alt="image-20250319233941889" style="zoom:50%;" />

**有序树**：树中结点的各子树从左到右有次序（最左边的位第一个孩子）
**无序树**：树中结点的各子树无次序
**森林**：是$m(m\geq0)$棵互不相交的树的集合
	   把根节点删除树就变成了森林
	   一棵树可以看成是一个特殊的森林
	   给森林中的各子树加上一个双亲结点，森林就变成了树
	   树一定是森林，森林不一定是树

#### 树结构和线性结构的比较

| 线性结构         | 树结构             |
| -------------   | ------------------ |
| 第一个元素 无前驱  | 根结点（只有一个） |
| 最后一个元素 | 叶子结点（可以有多个） |
| 其它数据元素 | 其它结点—中间结点 |
| 一个前驱，一个后继 | 一个双亲，多个孩子 |
| 一对一 | 一对多 |

### 5.1.3 二叉树的定义

**二叉树**是$n(n \geq 0)$个结点的有限集，它或者是空集$(n = 0)$，或者由一个**根节点**及**两颗互不相交**的分别称作这个根的**左子树**和**右子树**的二叉树组成

特点

1. 每个结点最多有俩孩子（**二叉树中不存在度大于2的节点**）
2. 子树有左右之分，其次序不能颠倒
3. 二叉树可以是空集合，根可以有空的左子树或空的右子树

注：二叉树**不是**树的特殊情况，它们是两个概念
	二叉树的结点的子树要区分**左子树**和**右子树**，即是只有一颗子树也要进行区分，说明它是左子树，还是右子树
	树当结点只有一个孩子时，就**无需区分**它是左还是右的次序，因此二者是不同的。这是二叉树和树的最主要的差别

<img src=".\img\image-20250326215109854.png" alt="image-20250326215109854" style="zoom: 67%;" /><img src=".\img\image-20250326215245559.png" alt="image-20250326215245559" style="zoom: 67%;" />

（也就是二叉树每个结点位置或者说次序都是固定的，可以是空，但是不可以说它没有位置，而树的结点位置是相对于别的结点来说的，没有别的结点时，它就无所谓左右了）

**二叉树的五种基本形态**

<img src=".\img\image-20250326220358216.png" alt="image-20250326220358216" style="zoom:50%;" align="left"/>

## 5.3 树和二叉树的抽象数据类型定义

二叉树的抽象数据类型定义
<img src=".\img\image-20250326222034427.png" alt="image-20250326222034427" style="zoom: 67%;" />
<img src=".\img\image-20250326222542767.png" alt="image-20250326222542767" style="zoom: 67%;" />

## 5.4 二叉树的性质和存储结构

**性质1**：在二叉树的第$i$层上**至多**有$2^{i-1}$个结点（$i\geq1$）·

**性质2**：深度为$k$的二叉树**至多**有$2^k - 1$个结点（$k\geq1$）

**性质3**：对任何一颗二叉树$T$，如果其叶子数为$n_0$，度为2的节点数为$n_2$，则$n_0 = n_2 + 1$

### 两种特殊形式的二叉树

顺序存储方式下可以复原

#### 满二叉树

一颗深度为`k`且有$2^k - 1$个结点的二叉树称为**满二叉树**
<img src=".\img\image-20250327223200514.png" alt="image-20250327223200514" style="zoom:67%;" />

特点：

1. 每一层上的结点数都是最大结点数（即**每层都满**）
2. 叶子结点全部在底层

对满二叉树结点位置进行编号

- 编号规则：从根节点开始，**自上而下，自左而右**
- 每一结点位置都有元素

满二叉树在同样深度的二叉树中**结点**个数最多
满二叉树在同样深度的二叉树中**叶子结点**个数最多

#### 完全二叉树

深度为`k`的具有`n`个结点的二叉树，当且仅当其每一个结点都与深度为`k`的**满二叉树**中**编号**为`1~n`的结点**一一对应**时，称之为**完全二叉树**

注：在满二叉树中，从最后一个结点开始，**连续**去掉**任意**个结点，即是一颗完全二叉树。
**一定是连续的去掉！！！**

特点：

1. 叶子只可能分布在层次最大的两层上
2. 对任一结点，如果其右子树的最大层次为`i`，则其左子树的最大层次为`i`或`i+1`

具有`n`个结点的完全二叉树的深度为$\left\lfloor{log2n}\right\rfloor+1$
注：$\lfloor{x}\rfloor$：称作`x`的底，表示不大于`x`的最大整数

如果对一棵有`n`个结点的**完全二叉树**，深度为$\lfloor{log_2n\rfloor+1}$的结点按层序编号（从第1层到第$\lfloor{log_2n}\rfloor+1$层，每层从左到右），则对任一结点`i`($1 \leq i \leq n$)，有

1. 如果`i=1`，则结点`i`是二叉树的根，无双亲；如果`i>1`，则其**双亲是结点$\lfloor i/2 \rfloor$
2. 如果`2i>n`，则结点`i`为叶子结点，无左孩子；否则，其**左孩子是结点2i**
3. 如果`2i+1>n`，则结点`i`无右孩子；否则，其**右孩子是结点2i+1**

### 二叉树的顺序存储结构

实现：按**满二叉树**的结点层次编号，依次存放二叉树中的数据元素

~~~ c++
// 二叉树顺序存储表示
#define MAXSIZE 100
typedef int Telemtype;
typedef Telemtype SqBiTree[MAXSIZE];
SqBiTree bt;
~~~

<img src=".\img\image-20250410191016020.png" alt="image-20250410191016020" style="zoom:67%;" align="left"/>

二叉树顺序存储的缺点：

**最坏情况**：深度为`k`的且只有`k`个结点的单支树需要长度为$2^k-1$的一维数组
<img src=".\img\image-20250410192532967.png" alt="image-20250410192532967" style="zoom:50%;" /><img src=".\img\image-20250410192616539.png" alt="image-20250410192616539" style="zoom:50%;" />

**特点**：结点间关系蕴含在其存储位置中浪费空间，适于存**满二叉树和完全二叉树**

### 二叉树的链式存储结构

<img src=".\img\image-20250410193508948.png" alt="image-20250410193508948" style="zoom: 67%;" /><img src=".\img\image-20250410193558568.png" alt="image-20250410193558568" style="zoom: 67%;" /><img src=".\img\image-20250410193646436.png" alt="image-20250410193646436" style="zoom:67%;" />

~~~ c++
//二叉链表存储结构
typedef struct BiNode {
    Telemtype data;
    struct BiNode *lchild, *rchild; // 左右孩子指针
}BiNode, *BiTree;
~~~

<img src=".\img\image-20250410194656716.png" alt="image-20250410194656716" style="zoom:67%;" align="left"/>

### 三叉链表

<img src=".\img\image-20250410195104279.png" alt="image-20250410195104279" style="zoom: 67%;" align="left"/>

## 5.5 **遍历二叉树**和线索二叉树

- **遍历定义**——顺着某一条搜索路径巡防二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次（又称周游）
  - “访问”的含义很广，可以是对结点作各种处理，如：输出结点的信息、修改结点的数据值等，但要求这种访问不破坏原来的数据结构
- **遍历目的**——得到树中所有结点的一个线性排列
- **遍历用途**——它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心

### 1. 遍历二叉树算法描述

遍历方法 
<img src=".\img\image-20250410210252520.png" alt="image-20250410210252520" style="zoom:50%;" />
依次遍历二叉树中的三个组成部分，便是遍历了整个二叉树
假设：`L`：遍历左子树    `D`：访问根节点    `R`：遍历右子树
则遍历整个二叉树方案共有：
`DLR`、`LDR`、`LRD`、`DRL`、`RDL`、`RLD`六种

若规定**先左后右**，则只有前三种情况：
	**DLR**——先（根）序遍历，
	**LDR**——中（根）序遍历，
	**LRD**——后（根）序遍历。
<img src=".\img\image-20250410211240767.png" alt="image-20250410211240767" style="zoom:67%;" />

| 先序遍历二叉树                                               | 中序遍历二叉树                                               | 后序遍历二叉树                                               |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 若二叉树为空，则空操作；<br />否则<br />1. 访问**根**结点<br />2. **先序遍历**左子树<br />3. **先序遍历**右子树 | 若二叉树为空，则空操作；<br />否则<br />1. **中序遍历**左子树<br />2. 访问**根**结点<br />3. **中序遍历**右子树 | 若二叉树为空，则空操作；<br />否则<br />1. **后序遍历**左子树<br />2. **后序遍历**右子树<br />3. 访问**根**结点 |

 由二叉树的递归定义可知，遍历左子树和遍历右子树可如同遍历二叉树一样“**递归**”进行
<img src=".\img\image-20250410214347596.png" alt="image-20250410214347596" style="zoom: 67%;" />
先序遍历的顺序为：`ABELDHMIJ`
中序遍历的顺序为：`ELBAMHIDJ`
后序遍历的顺序为：`LEBMIHJDA`

### 2. 根据遍历序列确定二叉树

- 若二叉树中各结点的值均不相同，则二叉树结点的先序序列、中序序列和后序序列都是唯一的
- 由二叉树的先序序列和中序序列，或由二叉树的后序序列和中序序列可以确定唯一一颗二叉树

### 遍历算法的实现-先序遍历

若二叉树为空，则空操作
若二叉树非空，
	访问**根节点**（`D`）
	前序遍历**左子树**（`L`）
	前序遍历**右子树**（`R`）
<img src=".\img\image-20250504195544671.png" alt="image-20250504195544671" style="zoom:50%;" />

~~~ c++
Status PreOrderTraverse(BiTree T) {
    if (T == NULL) return OK; //空二叉树
    else {
        Visit(T); //访问根结点
        PreOrderTraverse(T->lchild); //递归遍历左子树
        PreOrderTraverse(T->rchild); //递归遍历右子树
    }
}
~~~

### 遍历算法的实现-中序遍历

若二叉树为空，则空操作
否则：
	中序遍历**左子树**（`L`）
	访问**根节点**（`D`）
	中序遍历**右子树**（`R`）
<img src=".\img\image-20250504222445418.png" alt="image-20250504222445418" style="zoom:50%;" />

~~~ c++
Status InOrderTraverse(BiTree T) {
    if (T == NULL) return OK; //空二叉树
    else {
        InOrderTraverse(T->lchild); //递归遍历左子树
        Visit(T); //访问根节点
        InOrderTraverse(T->rchild); //递归遍历右子树
    }
}
~~~

### 遍历算法的实现-后序遍历

若二叉树为空，则空操作
否则：
	后序遍历**左子树**（`L`）
	后序遍历**右子树**（`R`）
	访问**根节点**（`D`）
<img src=".\img\image-20250504223027622.png" alt="image-20250504223027622" style="zoom:50%;" />

~~~ c++
Status PostOrderTraverse(BiTree T) {
    if (T == NULL) return OK; //空二叉树
    else {
        PostOrderTraverse(T->lchild); //递归遍历左子树
        PostOrderTraverse(T->rchild); //递归遍历右子树
        Visit(T); //访问根节点
    }
}
~~~

### 遍历算法的分析

- 如果去掉输出语句，从递归角度看，三种算法是完全相同的，或者说这三种算啊的访问路径是相同的，知识访问结点的时机不同 

### 遍历二叉树的非递归算法

中序遍历**非递归**算法

​	二叉树**中序遍历的非递归算法的关键**：在中序遍历过某结点的整个左子树后，如何找到该节点的**根**以及**右子树**

基本思想：
	建立一个**栈**
	**根**结点**进栈**，遍历**左子树**
	**根**结点**出栈**，输出根节点，遍历**右子树**

~~~ c++
Status InOrderTraverse(BiTree T) {
    BiTree p; 
    InitStack(S);
    p = T;
    while (p || !StackEmpty(S)) {
        if (p) {
            Push(S, p);
            p = p->lchild;
        } else {
            Pop(S, p);
            printf("%c", p->data);
            p = p->rchild;
        }
    }
    return OK;
}
~~~

 ### 二叉树的层次遍历

对于一颗二叉树，从根节点开始，按**从上到下，从左到右**的顺序访问每一个结点

每一个结点仅仅访问一次

算法设计思路：**使用一个队列**
	将根节点进队
	队不空时循环：从队列中出列一个结点`*p`，访问它
		若它有左孩子结点，将左孩子结点进队
		若它有右孩子结点，将右孩子结点进队

~~~ c++
void LevelOrder(BTNode *b) {
    BTNode *p;  // 用于指向当前访问的节点
    SqQueue *qu;  // 创建一个队列用于存储待访问的节点
    InitQueue(qu);  // 初始化队列
    enQueue(qu, b);  // 将根节点入队
    while(!QueueEmpty(qu)) {
        deQueue(qu, p);  // 出队一个节点
        printf("%c", p->data);  // 访问当前节点的数据
        if (p->lchild) enQueue(qu, p->lchild);  // 如果当前节点有左孩子，则将左孩子入队
        if (p->rchild) enQueue(qu, p->rchild);  // 如果当前节点有右孩子，则将右孩子入队
    }
}
~~~

### 二叉树遍历算法的应用——二叉树的简历

- 按先序遍历序列建立二叉树的二叉链表

  例：已知先序序列为：`ABCDEGF`

  1. 从键盘输入二叉树的结点信息，简历二叉树的存储结构
  2. 在建立二叉树的过程中**按照二叉树先序**方式建立

  <img src=".\img\image-20250505210703420.png" alt="image-20250505210703420" style="zoom:50%;" align="left"/>

  因为建立的二叉树不一定唯一，若想建立制定二叉树需要指定结点下的空结点，我们用`#`表示空结点

  如：`ABC##DE#G##F###`，建立的是图片左侧的二叉树

  ~~~ c++
  Status CreatBiTree(BiTree &T) {
      scanf(&ch);
      if (ch == "#") T=NULL;
      else {
          if(!(T=BiTNode*)malloc(sizeof(BiTNode)))    //T = new BiTNode;
              exit(OVERFLOW); 
          T->data = ch;   //生成根节点
          CreatBiTree(T->lchild);   //生成左子树
          CreatBiTree(T->rchild);   //生成右子树
      }
      return OK;
  }
  ~~~


### 二叉遍历算法的应用——复制二叉树

如果是空树，递归结束
否则，申请新结点空间，复制根节点
	递归复制左子树
	递归复制右子树

~~~ c++
int Copy(BiTree T, BiTree &NewT) {
    if (T == NULL) {  //空树返回0
        NewT = NULL;
        return 0;
    } else {
        NewT = new BiTNode;
        NewT->data = T->data;
        Copy(T->lchild, NewT->lchild);
        Copy(T->rchild, NewT->rchild);
    }
}
~~~

### 二叉树遍历算法的应用——计算二叉树深度

如果是空树，则深度为`0`
否则
	递归计算左子树深度记为`m`
	递归计算右子树深度记为`n`
	二叉树深度则为`m`与`n`的较大者加`1`

~~~ c++
int Depth(BiTree T) {
    if(T == NULL) return 0;
    else {
        m = Depth(T->lchild);
        n = Depth(T->rchild);
        if (m > n) return m + 1;
        else return n + 1;
    }
}
~~~

### 二叉树遍历算法的应用——计算二叉树结点总数

如果是空树，则结点个数为`0`
否则
	结点个数为左子树的结点个数+右子树的节点个数+`1`

~~~ c++
int NodeCount(BiTree T) {
    if (T == NULL) return 0;
    else reutrn NodeCount(T->lchild) + NodeCount(T->rchild) + 1;
}
~~~

### 二叉树遍历算法的应用——计算叶子结点数

如果是空树，则叶子结点个数为`0`
否则
	为左子树的叶子结点个数+右子树的叶子结点个数

~~~ c++
int LeadCount(BiTree T) {
    if (T == NULL) return 0;
    if (T->lchild == NULL && T->rchild == NULL) return 1;
    else return LeadCount(T->lchild) + LeadCount(T->rchild);
}
~~~

### 线索二叉树

利用而二叉链表中的空指针域：
如果某个结点的左孩子为空，则将空的左孩子指针与改为**指向其前驱**
如果某个结点的右孩子为空，则将空的右孩子指针与改为**指向其后继**
——这种**改变指向的指针**称为**线索**

加上了线索的二叉树成为**线索二叉树(Threaded Binary Tree)**

对二叉树按某种遍历次序使其变为线索二叉树的过程叫做**线索化**

<img src=".\img\image-20250506130237279.png" alt="image-20250506130237279" style="zoom:50%;" align="left"/>

为区分`lchild`和`rchild`指针到底是指向孩子的指针，还是指向前驱或者后继的指针，对二叉链表中每个结点**增设两个标志域`ltag`和`rtag`**，并约定：

`ltag = 0 lchild` 指向该结点的**左孩子**
`ltag = 1 lchild` 指向该结点的**前驱**
`rtag = 0 rchild` 指向该结点的**右孩子**
`rtag = 1 rchild` 指向该节点的**后继**

这样，结点的结构为：
<img src=".\img\image-20250506130759207.png" alt="image-20250506130759207" style="zoom:50%;" />

~~~ c++
typedef struct BiThrNode {
    int data;
    int ltag, rtag;
    struct BiThrNode *lchild, *rchild;
} BiThrNode, *BiThrTree;
~~~

