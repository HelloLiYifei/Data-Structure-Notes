# 线性表

## 2.1 线性表的定义和特点

**线性表是**具有相同特性的数据元素的一个有限序列
$$
(a_1,a_2,...a_{i-1},a_i,a_{i+1},...,a_n)
$$

- $a_1$是线性起点，$a_n$是线性终点
- $a_{i-1}$是$a_i$的直接前驱，$a_{i+1}$是$a_i$的直接后继
- 在数据元素$a_i$中，$_i$称为**下标**，是元素的序号，表示元素在表中的位置
- **$_n$**为元素总个数，即表长

**线性表(Linear List)**:

由**n(n >= 0)**个数据元素（结点）$a_1,a_2,...a_n$组成的**有限序列**。

- 其中数据元素的个数n定义为表的**长度**
- 当n=0时称为**空表**
- 将非空线性表（n>0）记作：$(a_1,a_2,...a_n)$
- 这里数据元素$ai(i)$

### 线性表的逻辑特征

- 从以上例子可看出线性表的逻辑特征是：

  - 非空线性表，有且仅有一个开始结点$a_1$，它没有直接前驱，而有且仅有一个直接后继$a_2$;
  - 有且仅有一个终端结点$a_n$，它没有直接后继，而仅有一个直接前驱$a_{n-1}$
  - 其余的内部结点$a_i(2 <= i <= n-1)$都有且仅有一个直接前驱$a_{i-1}$和一个直接后继$a_{i+1}$

  **线性表是一种典型的线性结构**

## 2.2 案例引入

**一元多项式的运算**：实现两个多项式加、减、乘运算
$$
P_n(x) = P_0 + P_1x + P_2x^2+ ... + P_nx^n
$$
线性表$P=(p_0,p_1,p_2,...,p_n)$
（每一项指数$i$都隐含在其系数$p_i$的序号中）
例如：$P(x) = 10 + 5x - 4x^2 + 3x^3 + 2x^4$

|指数(下标i)|0|1|2|3|4|
| ---- | ---- | ---- | ---- | ---- | ---- |
|系数p[i]|10|5|-4|3|2|

$R_n(x) = P_n(x) + Q_m(x)$
线性表$R = (p_0 + q_0, p_1 + q_1, p_2 + q_2,...,p_m + q_m, p_{m+1},...,p_n)$

**稀疏多项式的运算**
线性表A = ((7, 0), (3, 1), (9, 8) (5 ,17))
线性表B = ((8, 1), (22 , 7), (-9, 8))

- 创建一个**新数组C**
- 分别从头遍历比较a和b的每一项
  - **指数相同**，对应系数相加，若其和不为零，则在c中增加一个新项
  - **指数不相同**，则将指数较小的项赋值到c中
- 一个多项式已遍历**完毕**时，将另一个剩余项一次复制到c中即可

顺序存储结构存在问题: 存储空间分配不灵活，运算的空间复杂度高 => 链式存储结构

总结

- 线性表中的数据元素的类型可以为**简单类型**，也可以为**复杂类型**
- 许多实际应用问题所涉的基本操作有很大相似性，不应为每个具体应用单独编写一个程序
- 从具体应用抽象出共性的**逻辑结构和基本操作**（抽象数据类型），然后实现其**存储结构和基本操作**

## 2.3 线性表的类型定义

抽象数据类型线性表的定义如下：

ADT List {
	数据对象：$D = {a_i|a_i属于Elemset, (i = 1, 2, ..., n, n>=0)}$
	数据关系：$R = {<a_{i-1}, a_i>|a_{i - 1}, a_i属于D, (i = 2,3,...,n)}$
	基本操作：
		`InitList(&L);`	`DestoryList(&L);`
		`ListInsert(&L,i,e);`	`ListDelete(&L,i,&e);`
		......等等
} ADT List

### 基本操作（一）

- **InitList(&L)** (Initialization List)
  - 操作结果：构造一个空的线性表`L`
- **DestoryList(&L)**
  - 初始条件：线性表`L`已经存在
  - 操作结果：销毁线性表`L`
- **ClearList(&L)**
  - 初始条件：线性表`L`已经存在
  - 操作结果：将线性表`L`重置为空表

### 基本操作（二）

- **ListEmpty(L)**
  - 初始条件：线性表`L`已经存在
  - 操作结果：若线性表`L`为空表，则返回`TURE`；否则返回`FALSE`
- **ListLength(L)**
  - 初始条件：线性表`L`已经存在
  - 操作结果：返回线性表中`L`的数据元素个数

### 基本操作（三）

- **GetElem(L,i,&e)**
  - 初始条件：线性表`L`已经存在，`1<=i<=ListLength(L)`
  - 操作结果：用`e`返回线性表L中第`i`个数据元素的值
- **LocateElem(L,e,compare())**
  - 初始条件：线性表`L`已经存在，`compare()`是数据元素判定函数
  - 操作结果：返回`L`中第1个与`e`满足`compare()`的数据元素的位序。若这样的数据元素不存在则返回值为`0`

### 基本操作（四）

- **PriorElem(L, cur_e, &pre_e)**
  - 初始条件：线性表L已经存在
  - 操作结果：若`cur_e`是`L`的数据元素，且不是第一个，则用`pre_e`返回它的前驱，否则操作失败；`pre_e`无意义
- **NextElem(L, cur_e, &next_e)**
  - 初始条件：线性表L已经存在
  - 操作结果：若`cur_e`是`L`的数据元素，且不是最后一个，则用`next_e`返回它的后继，若操作失败则`next_e`无意义

### 基本操作（五）

- **ListInsert(&L,i,e)**

  - 初始条件：线性表L已经存在，`1<=i<=ListLength(L)+1`
  - 操作结果：在L的第i个位置之前插入新的数据元素e,L的长度加一

  插入元素e之前（长度为n）：$(a_1,a_2,...,a_{i-1},a_i,...,a_n)$

  插入元素e之后（长度为n+1）：$(a_1,a_2,...,a_{i-1},e,a_i,...,a_n)$

### 基本操作（六）

- **ListDelete(&L,i,&e)**

  - 初始条件：线性表L已经存在，1<=i<=ListLength(L)

  - 操作结果：删除L的第i个数据元素，并用e返回其值，L的 长度减一

    - 删除前（长度为n）

      ​	$(a_1,a_2,...,a_{i-1},a_i,a_{i+1},...,a_n)$

    - 删除后（长度为n-1）

      ​	$(a_1,a_2,...,a_{i-1},a_{i+1},...,a_n)$

- **ListTraverse(&L, visited())**

  - 初始条件：线性表L已经存在
  - 操作结果：依次对线性表中每个元素调用visited()

### 总结

- 以上所提及的运算是逻辑结构上定义的运算。只要给出这些运算的功能是“做什么”，至于“如何做”等实现细节，只有待确定了存储结构之后才考虑

## 2.4 线性表的顺序表示和实现

### 2.4.1 线性表的顺序存储表示

线性表的顺序表示又称为**顺序存储结构**或**顺序映像**

**顺序存储定义**：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构

#### 顺序存储结构

![image-20250205092626039](.\img\image-20250205092626039.png)

线性表顺序存储结构**占用一片连续的存储空间**。知道某个元素的存储位置就可以计算其他元素的存储位置

#### 顺序表中元素存储位置的计算

![image-20250205093018428](.\img\image-20250205093018428.png)

#### 顺序表的实现

顺序表的特点：物理位置相邻表示逻辑关系，任一元素均可随机存取

~~~ c
#define LIST_INIT_SIZE 100 // 线性表存储空间的初始分配量
typedef struct {
    ElemType elem[LIST_INIT_SIZE];
    int length; // 当前长度
} SqList;
~~~



#### 多项式的顺序存储结构类型定义

$P_n(x) = P_1x^{e_1} + P_2x^{e_2} + ... + P_mx^{e_m}$
线性表$P = ((p1, e1), (p2,e2),...,(pm,em))$

~~~ c
#define MAXSIZE 1000 // 多项式可能达到的最大长度

typedef struct {     // 多项式非零项的定义
    float p; // 系数
    int e;   // 指数
} Polynomial;

typedef struct {
    Polynomial *elem; // 存储空间的基地址
    int length;       // 多项式当前长度
} SqList;             // 多项式的顺序存储结构为SqList
~~~

### 2.4.2 顺序表的基本操作的实现

#### 线性表的基本操作

~~~ c
InitList(&L);          // 初始化擦欧总，建立一个空的线性表L
DestoryList(&L);       // 销毁已存在的线性表L
ClearList(&L);         // 将线性表L重置为空表
ListInsert(&L, i, e);  // 在线性表L中第i个位置插入新元素e
ListDelete(&L, i, &e); // 删除线性表L中第i个位置元素，并用e返回其值
IsEmpty(L);            // 若L为空表，则返回TRUE，否则返回FALSE
ListLength(L);         // 返回L中元素个数
LocateElem(L, e);      // L中查找给定值e相等的元素，若成功返回该元素在线性表中的序号，否则返回0
GetElem(L, i, &e);     // 将线性表L中的第i个位置元素返回给e
~~~

#### 操作算法中常用到的预定义常量和类型

~~~ c
// 函数结果状态代码
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE -1
#define OVERFLOW -2
//Status 函数的类型，其值是函数结果状态代码
typedef int Status;
typedef char ElemType;
~~~

#### 【算法2.1】

##### 线性表`L`的初始化（参数用引用）

~~~ c++
Status InitList_Sq(SqList &L)
{                                    // 构造一个空的顺序表L
    L.elem = new ElemType[MAXSIZE];  // 为顺序表分配空间
    if (!L.elem) { exit(OVERFLOW) }; // 存储分配失败退出
    L.length = 0;                    // 空表长度为0
    return OK;
}
~~~

##### 摧毁线性表L

~~~ c++
void DestoryList(Sqlist &L) {
    if(L.elem) delete L.elem; // 释放存储空间
}
~~~

##### 清空线性表L

~~~ c++
void ClearList(SqList &L) {
    L.length = 0; // 将线性表的长度置为0 
}
~~~

##### 求线性表L的长度

~~~ c++
int GetLength(SqList L) {
    return L.length; // 返回L中元素的个数
}
~~~

##### 判断线性表L是否为空

~~~ c++
int IsEmpty(SqList L) {
    if(L.length == 0) return 1;
    else return 0;   
}
~~~

#### 【算法2.2】

##### 顺序表的取值（根据位置i获取相应位置数据元素的内容）

~~~ c++
int GetElem(SqList L, int i, ElemType &e) {
   if( i < 1 || i > L.length) return ERROR;     // 判断i值是否合理，若不合理，返回ERROR
   e = L.elem[i-1];                             // 第i-1的单元存储着第i个数据
   return OK;
}
~~~

#### 【算法2.3】 

##### 顺序表的查找

- 在线性表L中查找与指定值`e`相同的数据元素的位置
- 从表的一端开始，逐个记录的关键字和给定值的比较，找到，返回该元素的位置序号，未找到，返回`0`

~~~ c++
int LocateElem(SqList L, ElemType e) {
    // 在顺序表L中查找值为e的数据元素，返回其序号
    for(i = 0; i < L.length; i++)
        if(L.elem[i] == e) return i+1; // 查找成功，返回序号
    return 0; // 查找失败，返回0
}
~~~

**算法分析**

- 因为查找算法**基本操作**为：将记录的关键字同给定值进行比较
  基本操作：`L.elem[i]==e`
- **平均查找长度ASL**(**A**verage **S**earch **L**ength)
  - 为确定记录在表中的位置，需要与给定值进行比较的关键字段个数的期望值叫做查找算法的**平均查找长度**
  - 对含有`n`个记录的表，查找成功时：$ASL=\sum_{i=1}^{n}{P_iC_i}$
  - 顺序表查找的平均查找长度：$ASL=P_1+2P_2+...+(n-1)P_{n-1}+nP_n$
  - 假设每个记录的查找概率相等：$P_i=1/n$
  - 则：$ASL_{SS}=\sum_{i=1}^n{P_iC_i} = \frac{1}{n}\sum_{i=1}^1{i}=\frac{n+1}{2}$

#### 【算法2.4】

##### 顺序表的插入

线性表的插入运算是指在表的第`i(i<=i<=n+1)`个位置上，插入一个新节点`e`，使长度为`n`的线性表`(a1,...,ai-1,ai,...,an)`变成长度为`n+1`的线性表`(a,...,ai-1,e,ai,...,an)`

![image-20250213222722511](.\img\image-20250213222722511.png)

**算法思想**:

1. 判断插入位置`i`是否合法
2. 判断顺序表的存储空间是否已满，若满返回`ERROR`
3. 将第`n`至第`i`位的元素依次移动一个位置，空出第`i`个位置
4. 要将插入的新元素`e`放入第`i`个位置

~~~ c++
Status LinkInsert(SqList &L, int i, ElemType e) {
  if (i < 1 || i > L.length + 1) return ERROR; // i值不合法
  if (L.length == MAXSIZE) return ERROR; // 当前存储空间已满
  for (int j = L.length - 1; j >= i - 1; j--)
    L.elem[j + 1] = L.elem[j]; // 插入位置及之后的元素后移
  L.elem[i - 1] = e; // 新元素插入
  ++L.length; // 表长增1
  return OK;
}
~~~

**算法分析**

算法时间主要耗费在移动元素的操作上

平均移动次数：
$$
E_{ins}=\frac{1}{n+1}\sum_{i=1} ^{n+1}{(n-i+1)}=\frac{1}{n+1}(n+...+1+0)=\frac{1}{n+1}\frac{n(n+1)}{2}=\frac{n}{2}
$$
顺序表插入算法的平均时间复杂度为$O(n)$

#### 【算法2.5】

##### 顺序表的删除

线性表的删除运算是指将表的第`i(1<=i<=n)`个结点删除
使长度为`n`的线性表$(a_1,...,a_{i-1},a_i,a_{i+1},...,a_n)$
变成长度为`n-1`的线性表$(a_1,...,a_{i-1},a_{i+1},...,a_n)$

![image-20250213231157521](.\img\image-20250213231157521.png)

**算法思想：**

1. 判断删除位置`i`是否合法（合法值为`1<=i<=n`）
2. 将欲删除的元素保留在`e`中
3. 将第`i+1`至第`n`位的元素依次向前移动一个位置
4. 表长减1，删除成功返回`OK`

~~~ c++
Status LinkDelete_Sq(SqList &L, int i) {
    if (i < 1 || i > L.length) return ERROR; // i值不合法
    for (int j = i; j <= L.length - 1; j++)
        L.elem[j - 1] = L.elem[j]; // 被删除元素之后的元素前移
    --L.length; // 表长减1
    return OK;
}
~~~

**算法分析**

算法时间主要耗费在移动元素的操作上
$$
E_{del}=\frac{1}{n}\sum_{i=1}^{n}{(n-1)}=\frac{1}{n}\frac{(n-1)n}{2}=\frac{n-1}{2}
$$
顺序表删除算法的平均时间复杂度为$O(n)$

### 顺序表小结

##### 顺序表（线性表的存储结构）的特点

1. 利用数据水元素和存储位置表示线性表中相邻元素之间的前后关系，即线性表的逻辑结构与存储结构一致
2. 在访问线性表时，可以快速地计算出任何一个数据元素的存储地址，因此可以粗略地认为，访问每个元素所花费时间相等

这种存取元素的方法被称为**随机存取法**

##### 顺序表的操作算法分析

- 时间复杂度
  - 查找，插入，删除算法的平均时间复杂度为$O(n)$
- 空间复杂度
  - 显然，顺序表操作的空间复杂度$S(n)=O(1)$（没有占用辅助空间）

##### 顺序表的优缺点

- 优点
  - 存储密度大（结点本身所占存储量/结点结构所占存储量）
  - 可以随机存取表中任一元素
- 缺点
  - 在插入、删除某一元素时，需要移动大量元素
  - 浪费存储空间
  - 属于静态存储形式，数据元素的个数不能自由扩充
