# 线性表

## 2.1 线性表的定义和特点

**线性表是**具有相同特性的数据元素的一个有限序列
$$
(a_1,a_2,...a_{i-1},a_i,a_{i+1},...,a_n)
$$

- $a_1$是线性起点，$a_n$是线性终点
- $a_{i-1}$是$a_i$的直接前驱，$a_{i+1}$是$a_i$的直接后继
- 在数据元素$a_i$中，$_i$称为**下标**，是元素的序号，表示元素在表中的位置
- **$_n$**为元素总个数，即表长

**线性表(Linear List)**:

由**n(n >= 0)**个数据元素（结点）$a_1,a_2,...a_n$组成的**有限序列**。

- 其中数据元素的个数n定义为表的**长度**
- 当n=0时称为**空表**
- 将非空线性表（n>0）记作：$(a_1,a_2,...a_n)$
- 这里数据元素$ai(i)$

### 线性表的逻辑特征

- 从以上例子可看出线性表的逻辑特征是：

  - 非空线性表，有且仅有一个开始结点$a_1$，它没有直接前驱，而有且仅有一个直接后继$a_2$;
  - 有且仅有一个终端结点$a_n$，它没有直接后继，而仅有一个直接前驱$a_{n-1}$
  - 其余的内部结点$a_i(2 <= i <= n-1)$都有且仅有一个直接前驱$a_{i-1}$和一个直接后继$a_{i+1}$

  **线性表是一种典型的线性结构**

## 2.2 案例引入

**一元多项式的运算**：实现两个多项式加、减、乘运算
$$
P_n(x) = P_0 + P_2x + P_2x^2+ ... + P_nx^n
$$
线性表$P=(p_0,p_1,p_2,...,p_n)$
（每一项指数$i$都隐含在其系数$p_i$的序号中）
例如：$P(x) = 10 + 5x - 4x^2 + 3x^3 + 2x^4$

|指数(下标i)|0|1|2|3|4|
| ---- | ---- | ---- | ---- | ---- | ---- |
|系数p[i]|10|5|-4|3|2|

$R_n(x) = P_n(x) + Q_m(x)$
线性表$R = (p_0 + q_0, p_1 + q_1, p_2 + q_2,...,p_m + q_m, p_{m+1},...,p_n)$

**稀疏多项式的运算**
线性表A = ((7, 0), (3, 1), (9, 8) (5 ,17))
线性表B = ((8, 1), (22 , 7), (-9, 8))

- 创建一个**新数组C**
- 分别从头遍历比较a和b的每一项
  - **指数相同**，对应系数相加，若其和不为零，则在c中增加一个新项
  - **指数不相同**，则将指数较小的项赋值到c中
- 一个多项式已遍历**完毕**时，将另一个剩余项一次复制到c中即可

顺序存储结构存在问题: 存储空间分配不灵活，运算的空间复杂度高 => 链式存储结构

总结

- 线性表中的数据元素的类型可以为**简单类型**，也可以为**复杂类型**
- 许多实际应用问题所涉的基本操作有很大相似性，不应为每个具体应用单独编写一个程序
- 从具体应用抽象出共性的**逻辑结构和基本操作**（抽象数据类型），然后实现其**存储结构和基本操作**

## 2.3 线性表的类型定义

抽象数据类型线性表的定义如下：

ADT List {
	数据对象：$D = {a_i|a_i属于Elemset, (i = 1, 2, ..., n, n>=0)}$
	数据关系：$R = {<a_{i-1}, a_i>|a_{i - 1}, a_i属于D, (i = 2,3,...,n)}$
	基本操作：
		InitList(&L);	DestoryList(&L);
		ListInsert(&L,i,e);	ListDelete(&L,i,&e);
		......等等
} ADT List

### 基本操作（一）

- **InitList(&L)** (Initialization List)
  - 操作结果：构造一个空的线性表L
- **DestoryList(&L)**
  - 初始条件：线性表L已经存在
  - 操作结果：销毁线性表L
- **ClearList(&L)**
  - 初始条件：线性表L已经存在
  - 操作结果：将线性表L重置为空表

### 基本操作（二）

- **ListEmpty(L)**
  - 初始条件：线性表L已经存在
  - 操作结果：若线性表L为空表，则返回TURE；否则返回FALSE
- **ListLength(L)**
  - 初始条件：线性表L已经存在
  - 操作结果：返回线性表中L的数据元素个数

### 基本操作（三）

- **GetElem(L,i,&e)**
  - 初始条件：线性表L已经存在，1<=i<=ListLength(L)
  - 操作结果：用e返回线性表L中第i个数据元素的值
- **LocateElem(L,e,compare())**
  - 初始条件：线性表L已经存在，compare()是数据元素判定函数
  - 操作结果：返回L中第1个与e满足compare()的数据元素的位序。若这样的数据元素不存在则返回值为0

### 基本操作（四）

- **PriorElem(L, cur_e, &pre_e)**
  - 初始条件：线性表L已经存在
  - 操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败；pre_e无意义
- **NextElem(L, cur_e, &next_e)**
  - 初始条件：线性表L已经存在
  - 操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，若操作失败则next_e无意义

### 基本操作（五）

- **ListInsert(&L,i,e)**

  - 初始条件：线性表L已经存在，1<=i<=ListLength(L)+1
  - 操作结果：在L的第i个位置之前插入新的数据元素e,L的长度加一

  插入元素e之前（长度为n）：$(a_1,a_2,...,a_{i-1},a_i,...,a_n)$

  插入元素e之后（长度为n+1）：$(a_1,a_2,...,a_{i-1},e,a_i,...,a_n)$

### 基本操作（六）

- **ListDelete(&L,i,&e)**

  - 初始条件：线性表L已经存在，1<=i<=ListLength(L)

  - 操作结果：删除L的第i个数据元素，并用e返回其值，L的 长度减一

    - 删除前（长度为n）

      ​	$(a_1,a_2,...,a_{i-1},a_i,a_{i+1},...,a_n)$

    - 删除后（长度为n-1）

      ​	$(a_1,a_2,...,a_{i-1},a_{i+1},...,a_n)$

- **ListTraverse(&L, visited())**

  - 初始条件：线性表L已经存在
  - 操作结果：依次对线性表中每个元素调用visited()

### 总结

- 以上所提及的运算是逻辑结构上定义的运算。只要给出这些运算的功能是“做什么”，至于“如何做”等实现细节，只有待确定了存储结构之后才考虑
